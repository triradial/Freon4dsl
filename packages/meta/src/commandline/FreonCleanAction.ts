import { CommandLineAction, CommandLineFlagParameter, CommandLineStringParameter } from "@rushstack/ts-command-line";
import { LanguageGenerator } from "../languagedef/generator/LanguageGenerator.js";
import { EditorGenerator } from "../editordef/generator/EditorGenerator.js";
import { ReaderWriterGenerator } from "../parsergen/ReaderWriterGenerator.js";
import { ScoperGenerator } from "../scoperdef/generator/ScoperGenerator.js";
import { ValidatorGenerator } from "../validatordef/generator/ValidatorGenerator.js";
import { FreonTyperGenerator } from "../typerdef/generator/FreonTyperGenerator.js";
import { MetaLogger } from "../utils/index.js";
import { GenerationStatus, FileUtil } from "../utils/index.js";
import { LanguageParser } from "../languagedef/parser/LanguageParser.js";
import { FreMetaLanguage } from "../languagedef/metalanguage/index.js";

const LOGGER = new MetaLogger("FreonCleanAction"); // .mute();

export class FreonCleanAction extends CommandLineAction {
    private outputFolderArg: CommandLineStringParameter;
    private defFolderArg: CommandLineStringParameter;
    protected forceFlag: CommandLineFlagParameter;

    protected outputFolder: string = "";
    private defFolder: string = "";
    private force: boolean = false;

    protected languageGenerator: LanguageGenerator = new LanguageGenerator();
    protected editorGenerator: EditorGenerator = new EditorGenerator();
    protected parserGenerator: ReaderWriterGenerator = new ReaderWriterGenerator();
    protected scoperGenerator: ScoperGenerator = new ScoperGenerator();
    protected validatorGenerator: ValidatorGenerator = new ValidatorGenerator();
    protected typerGenerator: FreonTyperGenerator = new FreonTyperGenerator();
    private language?: FreMetaLanguage;

    public constructor() {
        super({
            actionName: "clean-it",
            summary: "Removes the generated TypeScript code for all parts of the work environment for your language",
            documentation:
                "Removes the TypeScript code for the language implementation, the editor, the scoper, the typer, the reader, the writer, and the " +
                "validator. Any files that may contain customizations are left untouched.",
        });

        this.forceFlag = this.defineFlagParameter({
            parameterLongName: "--force",
            parameterShortName: "-f",
            description: "Remove every file generated by Freon, including possibly customized files.",
        });
        this.defFolderArg = this.defineStringParameter({
            argumentName: "DEFINITIONS_DIR",
            defaultValue: "defs",
            parameterLongName: "--definitions",
            parameterShortName: "-d",
            description: "Folder where your language definition files can be found - needed when the force flag is set",
        });
        this.outputFolderArg = this.defineStringParameter({
            argumentName: "OUTPUT_DIR",
            defaultValue: ".",
            parameterLongName: "--output",
            parameterShortName: "-o",
            description: "The directory where the generated files are located",
            required: false,
        });
    }

    protected onExecute(): Promise<void> {
        const self = this;
        self.outputFolder = this.outputFolderArg.value ? this.outputFolderArg.value : "";
        self.force = this.forceFlag.value;
        self.defFolder = this.defFolderArg.value ? this.defFolderArg.value : "";
        // @ts-ignore
        // error TS6133: 'resolve' is declared but its value is never read.
        // error TS6133: 'reject' is declared but its value is never read.
        // The parameters are expected by the constructor of Promise.
        return new Promise(function (resolve, reject) {
            self.doClean();
        });
    }

    doClean(): void {
        LOGGER.info("Removing of all parts of your language");
        // LOGGER.log("Output will be cleaned from: " + this.outputFolder);
        if (this.outputFolder.length === 0) {
            LOGGER.error("No folder to be cleaned provided.");
            return;
        }

        // when the force flag is present we need to parse the definition ast files
        // because some generators must remove files with names based on the language
        if (this.force) {
            if (this.defFolder.length === 0) {
                LOGGER.error("A definition folder must be provided when the force flag is used.");
            } else {
                LOGGER.info(
                    "Force flag is present therefore we need to parse the definition ast files, because some generators must remove files with names based on the language.",
                );
                this.findLanguage();
            }
        }
        // clean the workspace
        try {
            this.cleanLanguage();
            this.cleanEditorAndParser();
            this.cleanValidator();
            this.cleanScoper();
            this.cleanTyper();
        } catch (e: unknown) {
            if (e instanceof Error) {
                LOGGER.error("Stopping cleaning because of errors: " + e.message + "\n");
            }
        }
    }

    private cleanTyper = () => {
        LOGGER.log("Cleaning typer");
        try {
            this.typerGenerator.outputfolder = this.outputFolder;
            if (!!this.language) {
                this.typerGenerator.language = this.language;
            }
            this.typerGenerator.clean(this.force);
        } catch (e: unknown) {
            if (e instanceof Error) {
                // LOGGER.error("Stopping typer cleansing because of errors: " + e.message + "\n" + e.stack);
                LOGGER.error("Stopping typer cleansing because of errors: " + e.message);
            }
        }
    };

    private cleanScoper = () => {
        LOGGER.log("Cleaning scoper");
        try {
            this.scoperGenerator.outputfolder = this.outputFolder;
            if (!!this.language) {
                this.scoperGenerator.language = this.language;
            }
            this.scoperGenerator.clean(this.force);
        } catch (e: unknown) {
            if (e instanceof Error) {
                // LOGGER.error("Stopping scoper cleansing because of errors: " + e.message + "\n" + e.stack);
                LOGGER.error("Stopping scoper cleansing because of errors: " + e.message);
            }
        }
    };

    private cleanValidator = () => {
        LOGGER.log("Cleaning validator");
        try {
            this.validatorGenerator.outputfolder = this.outputFolder;
            if (!!this.language) {
                this.validatorGenerator.language = this.language;
            }
            this.validatorGenerator.clean(this.force);
        } catch (e: unknown) {
            if (e instanceof Error) {
                // LOGGER.error("Stopping validator cleansing because of errors: " + e.message + "\n" + e.stack);
                LOGGER.error("Stopping validator cleansing because of errors: " + e.message);
            }
        }
    };

    private cleanEditorAndParser = () => {
        LOGGER.log("Cleaning editor, reader and writer");
        try {
            this.editorGenerator.outputfolder = this.outputFolder;
            if (!!this.language) {
                this.editorGenerator.language = this.language;
            }
            this.editorGenerator.clean(this.force);

            this.parserGenerator.outputfolder = this.outputFolder;
            if (!!this.language) {
                this.parserGenerator.language = this.language;
            }
            this.parserGenerator.clean(this.force);
        } catch (e: unknown) {
            if (e instanceof Error) {
                // LOGGER.error("Stopping editor and parser cleansing because of errors: " + e.message + "\n" + e.stack);
                LOGGER.error("Stopping editor, reader and writer cleansing because of errors: " + e.message);
            }
        }
    };

    private cleanLanguage = () => {
        // clean the language
        LOGGER.log("Cleaning language structure");
        this.languageGenerator.outputfolder = this.outputFolder;
        this.languageGenerator.clean(this.force);
    };

    protected findLanguage() {
        if (!this.defFolder) {
            throw new Error("No definitions folder, exiting.");
        }
        const generationStatus = new GenerationStatus();
        const languageFiles: string[] = [];
        const myFileSet: string[] = FileUtil.findFiles(this.defFolder, generationStatus);
        if (myFileSet.length > 0) {
            for (const filename of myFileSet) {
                if (/\.ast$/.test(filename)) {
                    languageFiles.push(filename);
                }
            }
            this.language = new LanguageParser().parseMulti(languageFiles);
        }
    }
}
