/* tslint:disable:jsdoc-format */
// Generated by the Freon Language Generator.
import { net } from "net.akehurst.language-agl-processor";
import SPPTBranch = net.akehurst.language.api.sppt.SPPTBranch;
import {
    MetaElementReference,
    FreMetaClassifier,
    FreMetaLimitedConcept,
    FreMetaInstance,
    FreMetaProperty,
    FreMetaConcept,
} from "../../languagedef/metalanguage/index.js";
import {
    TyperDef,
    FretAnyTypeSpec,
    FretPropertyCallExp,
    FretSelfExp,
    FretAnytypeExp,
    FretLimitedInstanceExp,
    FretWhereExp,
    FretFunctionCallExp,
    FretInferenceRule,
    FretLimitedRule,
    FretExp,
    FretProperty,
    FretEqualsExp,
    FretConformsExp,
} from "../metalanguage/index.js";
import { FreTyperSyntaxAnalyser } from "./FreTyperSyntaxAnalyser.js";
import {
    FretTypeConcept,
    FretClassifierSpec,
    FretTypeRule,
    FretVarCallExp,
    FretVarDecl,
    FretCreateExp,
    FretPropInstance,
    FretBinaryExp,
    FretConformanceRule,
    FretEqualsRule,
} from "../metalanguage/index.js";
import SPPTBranchFromInput = net.akehurst.language.agl.sppt.SPPTBranchFromInput;

/**
 * This class is the (mainly) generated syntax analyser that reforms the parsed
 * typer definition into instances of our metamodel.
 * The differences are: (1) a parse location is added,
 * (2) the names of FreElementReferences are adjusted.
 */
export class FreTyperDefSyntaxAnalyserPart {
    mainAnalyser: FreTyperSyntaxAnalyser;

    constructor(mainAnalyser: FreTyperSyntaxAnalyser) {
        this.mainAnalyser = mainAnalyser;
    }

    /**
     * Method to transform branches that match the following rule:
     * TyperDef = 'typer'
     *	 ( 'istype' '\{' [ __fre_reference / ',' ]* '}' )?
     *	 FretTypeConcept*
     *	 ( 'hastype' '\{' [ __fre_reference / ',' ]* '}' )?
     *	 FretAnyTypeSpec?
     *	 FretClassifierSpec* ;
     * @param branch
     * @private
     */
    public transformTyperDef(branch: SPPTBranch): TyperDef {
        // console.log('transformTyperDef called: ' + branch.name);
        let __types: MetaElementReference<FreMetaClassifier>[] = [];
        let __typeConcepts: FretTypeConcept[];
        let __conceptsWithType: MetaElementReference<FreMetaClassifier>[] = [];
        let __anyTypeSpec: FretAnyTypeSpec | undefined;
        let __classifierSpecs: FretClassifierSpec[];
        const children = this.mainAnalyser.getChildren(branch);
        if (!children[1].isEmptyMatch) {
            // RHSOptionalGroup
            const _optGroup = this.mainAnalyser.getGroup(children[1]);
            const _propItem = this.mainAnalyser.getChildren(_optGroup);

            __types = this.mainAnalyser.transformSharedPackedParseTreeRefList<FreMetaClassifier>(
                _propItem[2],
                "FreClassifier",
                ",",
            ); // RHSRefListWithSeparator
        } // RHSPartListEntry
        if (children[2].name !== "FretTypeConcept") {
            __typeConcepts = this.mainAnalyser.transformSharedPackedParseTreeList<FretTypeConcept>(children[2]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __typeConcepts = [];
            for (const child of children) {
                __typeConcepts.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        }
        if (!children[3].isEmptyMatch) {
            // RHSOptionalGroup
            const _optGroup = this.mainAnalyser.getGroup(children[3]);
            const _propItem = this.mainAnalyser.getChildren(_optGroup);

            __conceptsWithType = this.mainAnalyser.transformSharedPackedParseTreeRefList<FreMetaClassifier>(
                _propItem[2],
                "FreClassifier",
                ",",
            ); // RHSRefListWithSeparator
        }
        if (!children[4].isEmptyMatch) {
            // RHSOptionalGroup
            const _optBranch = this.mainAnalyser.getChildren(children[4]);
            __anyTypeSpec = this.mainAnalyser.transformSharedPackedParseTreeNode(_optBranch[0]); // RHSPartEntry
        } // RHSPartListEntry
        if (children[5].name !== "FretClassifierSpec") {
            __classifierSpecs = this.mainAnalyser.transformSharedPackedParseTreeList<FretClassifierSpec>(children[5]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __classifierSpecs = [];
            for (const child of children) {
                __classifierSpecs.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        }

        return TyperDef.create({
            $types: __types,
            typeConcepts: __typeConcepts,
            $conceptsWithType: __conceptsWithType,
            anyTypeSpec: __anyTypeSpec,
            classifierSpecs: __classifierSpecs,
            aglParseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretTypeConcept = 'type' identifier ( 'base' __fre_reference )?
     *	 '\{'
     *	 ( FretProperty ';' )*
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformFretTypeConcept(branch: SPPTBranch): FretTypeConcept {
        // console.log('transformFretTypeConcept called: ' + branch.name);
        let __name: string;
        let __base: MetaElementReference<FreMetaConcept> | undefined = undefined;
        let __properties: FretProperty[];
        const children = this.mainAnalyser.getChildren(branch);
        __name = this.mainAnalyser.transformSharedPackedParseTreeNode(children[1]); // RHSPrimEntry

        if (!children[2].isEmptyMatch) {
            // RHSOptionalGroup
            const _optGroup = this.mainAnalyser.getGroup(children[2]);
            const _propItem = this.mainAnalyser.getChildren(_optGroup);
            __base = this.mainAnalyser.freNodeRef<FreMetaConcept>(_propItem[1], "FreConcept"); // RHSRefEntry
        } // RHSListGroup
        __properties = [];
        const _myList = this.mainAnalyser.getChildren(children[4]);
        _myList.forEach((subNode: SPPTBranchFromInput) => {
            const _transformed = this.mainAnalyser.transformSharedPackedParseTreeNode(
                subNode.nonSkipChildren?.toArray()[0],
            );
            if (!!_transformed) {
                __properties.push(_transformed);
            }
        });
        return FretTypeConcept.create({
            name: __name,
            base: __base,
            properties: __properties,
            aglParseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretAnyTypeSpec = 'anytype' '\{'
     *	 FretTypeRule*
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformFretAnyTypeSpec(branch: SPPTBranch): FretAnyTypeSpec {
        // console.log('transformFretAnyTypeSpec called: ' + branch.name);
        let __rules: FretTypeRule[];
        const children = this.mainAnalyser.getChildren(branch); // RHSPartListEntry
        if (children[2].name !== "FretTypeRule") {
            __rules = this.mainAnalyser.transformSharedPackedParseTreeList<FretTypeRule>(children[2]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __rules = [];
            for (const child of children) {
                __rules.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        }
        return FretAnyTypeSpec.create({ rules: __rules, aglParseLocation: this.mainAnalyser.location(branch) });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretInferenceRule = 'infertype' FretExp ';' ;
     * @param branch
     * @private
     */
    public transformFretInferenceRule(branch: SPPTBranch): FretInferenceRule {
        // console.log('transformFretInferenceRule called: ' + branch.name);
        let __exp: FretExp;
        const children = this.mainAnalyser.getChildren(branch);
        __exp = this.mainAnalyser.transformSharedPackedParseTreeNode(children[1]); // RHSPartEntry
        return FretInferenceRule.create({ exp: __exp, aglParseLocation: this.mainAnalyser.location(branch) });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretPropertyCallExp = FretExp '.' __fre_reference ;
     * @param branch
     * @private
     */
    public transformFretPropertyCallExp(branch: SPPTBranch): FretPropertyCallExp {
        // console.log('transformFretPropertyCallExp called: ' + branch.name);
        let __source: FretExp;
        let __property: MetaElementReference<FreMetaProperty>;
        const children = this.mainAnalyser.getChildren(branch);
        __source = this.mainAnalyser.transformSharedPackedParseTreeNode(children[0]); // RHSPartEntry
        __property = this.mainAnalyser.freNodeRef<FreMetaProperty>(children[2], "FreProperty"); // RHSRefEntry
        return FretPropertyCallExp.create({
            source: __source,
            $property: __property,
            aglParseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretSelfExp = 'self' ;
     * @param branch
     * @private
     */
    public transformFretSelfExp(branch: SPPTBranch): FretSelfExp {
        // console.log('transformFretSelfExp called: ' + branch.name);

        // const children = this.mainAnalyser.getChildren(branch);
        return FretSelfExp.create({ aglParseLocation: this.mainAnalyser.location(branch) });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretAnytypeExp = 'anytype' ;
     * @param branch
     * @private
     */
    public transformFretAnytypeExp(branch: SPPTBranch): FretAnytypeExp {
        // console.log('transformFretAnytypeExp called: ' + branch.name);

        // const children = this.mainAnalyser.getChildren(branch);
        return FretAnytypeExp.create({ aglParseLocation: this.mainAnalyser.location(branch) });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretVarCallExp = __fre_reference ;
     * @param branch
     * @private
     */
    public transformFretVarCallExp(branch: SPPTBranch): FretVarCallExp {
        // console.log('transformFretVarCallExp called: ' + branch.name);
        let __variable: MetaElementReference<FretVarDecl>;
        const children = this.mainAnalyser.getChildren(branch);
        __variable = this.mainAnalyser.freNodeRef<FretVarDecl>(children[0], "FretVarDecl"); // RHSRefEntry
        return FretVarCallExp.create({ $variable: __variable, aglParseLocation: this.mainAnalyser.location(branch) });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretCreateExp = __fre_reference '\{' [ FretPropInstance / ',' ]* '}' ;
     * @param branch
     * @private
     */
    public transformFretCreateExp(branch: SPPTBranch): FretCreateExp {
        // console.log('transformFretCreateExp called: ' + branch.name);
        let __type: MetaElementReference<FreMetaClassifier>;
        let __propertyDefs: FretPropInstance[];
        const children = this.mainAnalyser.getChildren(branch);
        __type = this.mainAnalyser.freNodeRef<FreMetaClassifier>(children[0], "FreClassifier"); // RHSRefEntry
        __propertyDefs = this.mainAnalyser.transformSharedPackedParseTreeList<FretPropInstance>(children[2], ","); // RHSPartListWithSeparator
        return FretCreateExp.create({
            $type: __type,
            propertyDefs: __propertyDefs,
            aglParseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretPropInstance = __fre_reference ':' FretExp ;
     * @param branch
     * @private
     */
    public transformFretPropInstance(branch: SPPTBranch): FretPropInstance {
        // console.log('transformFretPropInstance called: ' + branch.name);
        let __property: MetaElementReference<FreMetaProperty>;
        let __value: FretExp;
        const children = this.mainAnalyser.getChildren(branch);
        __property = this.mainAnalyser.freNodeRef<FreMetaProperty>(children[0], "FreProperty"); // RHSRefEntry
        __value = this.mainAnalyser.transformSharedPackedParseTreeNode(children[2]); // RHSPartEntry
        return FretPropInstance.create({
            $property: __property,
            value: __value,
            aglParseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretFunctionCallExp = identifier '(' [ FretExp / ',' ]* ')' ;
     * @param branch
     * @private
     */
    public transformFretFunctionCallExp(branch: SPPTBranch): FretFunctionCallExp {
        // console.log('transformFretFunctionCallExp called: ' + branch.name);
        let __calledFunction: string;
        let __arguments: FretExp[];
        const children = this.mainAnalyser.getChildren(branch);
        __calledFunction = this.mainAnalyser.transformSharedPackedParseTreeNode(children[0]); // RHSPrimEntry
        __arguments = this.mainAnalyser.transformSharedPackedParseTreeList<FretExp>(children[2], ","); // RHSPartListWithSeparator
        return FretFunctionCallExp.create({
            calledFunction: __calledFunction,
            actualParameters: __arguments,
            aglParseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretLimitedInstanceExp = ( __fre_reference ':' )?
     *	 __fre_reference ;
     * @param branch
     * @private
     */
    public transformFretLimitedInstanceExp(branch: SPPTBranch): FretLimitedInstanceExp {
        // console.log('transformFretLimitedInstanceExp called: ' + branch.name);
        let __myLimited: MetaElementReference<FreMetaLimitedConcept> | undefined = undefined;
        let __myInstance: MetaElementReference<FreMetaInstance>;
        const children = this.mainAnalyser.getChildren(branch);
        if (!children[0].isEmptyMatch) {
            // RHSOptionalGroup
            const _optGroup = this.mainAnalyser.getGroup(children[0]);
            const _propItem = this.mainAnalyser.getChildren(_optGroup);
            __myLimited = this.mainAnalyser.freNodeRef<FreMetaLimitedConcept>(_propItem[0], "FreLimitedConcept"); // RHSRefEntry
        }
        __myInstance = this.mainAnalyser.freNodeRef<FreMetaInstance>(children[1], "FreInstance"); // RHSRefEntry
        return FretLimitedInstanceExp.create({
            $myLimited: __myLimited,
            $myInstance: __myInstance,
            aglParseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretWhereExp = FretVarDecl 'where' '\{'
     *	 ( __fre_binary_FretExp ';' )*
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformFretWhereExp(branch: SPPTBranch): FretWhereExp {
        // console.log('transformFretWhereExp called: ' + branch.name);
        let __variable: FretVarDecl;
        let __conditions: FretBinaryExp[];
        const children = this.mainAnalyser.getChildren(branch);
        __variable = this.mainAnalyser.transformSharedPackedParseTreeNode(children[0]); // RHSPartEntry
        // RHSBinExpListWithTerminator
        __conditions = [];
        const _myList = this.mainAnalyser.getChildren(children[3]);
        _myList.forEach((subNode: SPPTBranchFromInput) => {
            const _transformed = this.mainAnalyser.transformSharedPackedParseTreeNode(
                subNode.nonSkipChildren?.toArray()[0],
            );
            if (!!_transformed) {
                __conditions.push(_transformed);
            }
        });
        return FretWhereExp.create({
            variable: __variable,
            conditions: __conditions,
            aglParseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretVarDecl = identifier ':' __fre_reference ;
     * @param branch
     * @private
     */
    public transformFretVarDecl(branch: SPPTBranch): FretVarDecl {
        // console.log('transformFretVarDecl called: ' + branch.name);
        let __name: string;
        let __type: MetaElementReference<FreMetaClassifier>;
        const children = this.mainAnalyser.getChildren(branch);
        __name = this.mainAnalyser.transformSharedPackedParseTreeNode(children[0]); // RHSPrimEntry
        __type = this.mainAnalyser.freNodeRef<FreMetaClassifier>(children[2], "FreClassifier"); // RHSRefEntry
        return FretVarDecl.create({
            name: __name,
            $type: __type,
            aglParseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretConformanceRule = 'conformsto' FretExp ';' ;
     * @param branch
     * @private
     */
    public transformFretConformanceRule(branch: SPPTBranch): FretConformanceRule {
        // console.log('transformFretConformanceRule called: ' + branch.name);
        let __exp: FretExp;
        const children = this.mainAnalyser.getChildren(branch);
        __exp = this.mainAnalyser.transformSharedPackedParseTreeNode(children[1]); // RHSPartEntry
        return FretConformanceRule.create({ exp: __exp, aglParseLocation: this.mainAnalyser.location(branch) });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretEqualsRule = 'equalsto' FretExp ';' ;
     * @param branch
     * @private
     */
    public transformFretEqualsRule(branch: SPPTBranch): FretEqualsRule {
        // console.log('transformFretEqualsRule called: ' + branch.name);
        let __exp: FretExp;
        const children = this.mainAnalyser.getChildren(branch);
        __exp = this.mainAnalyser.transformSharedPackedParseTreeNode(children[1]); // RHSPartEntry
        return FretEqualsRule.create({ exp: __exp, aglParseLocation: this.mainAnalyser.location(branch) });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretLimitedRule = FretExp ';' ;
     * @param branch
     * @private
     */
    public transformFretLimitedRule(branch: SPPTBranch): FretLimitedRule {
        // console.log('transformFretLimitedRule called: ' + branch.name);
        let __exp: FretExp;
        const children = this.mainAnalyser.getChildren(branch);
        __exp = this.mainAnalyser.transformSharedPackedParseTreeNode(children[0]); // RHSPartEntry
        return FretLimitedRule.create({ exp: __exp, aglParseLocation: this.mainAnalyser.location(branch) });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretClassifierSpec = __fre_reference '\{'
     *	 FretTypeRule*
     *	 '}' ;
     * @param branch
     * @private
     */
    public transformFretClassifierSpec(branch: SPPTBranch): FretClassifierSpec {
        // console.log('transformFretClassifierSpec called: ' + branch.name);
        let __myClassifier: MetaElementReference<FreMetaClassifier>;
        let __rules: FretTypeRule[];
        const children = this.mainAnalyser.getChildren(branch);
        __myClassifier = this.mainAnalyser.freNodeRef<FreMetaClassifier>(children[0], "FreClassifier"); // RHSRefEntry
        // RHSPartListEntry
        if (children[2].name !== "FretTypeRule") {
            __rules = this.mainAnalyser.transformSharedPackedParseTreeList<FretTypeRule>(children[2]);
        } else {
            // special case: only when this entry is the single rhs entry of this rule
            __rules = [];
            for (const child of children) {
                __rules.push(this.mainAnalyser.transformSharedPackedParseTreeNode(child));
            }
        }
        return FretClassifierSpec.create({
            $myClassifier: __myClassifier,
            rules: __rules,
            aglParseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretProperty = identifier ':' __fre_reference ;
     * @param branch
     * @private
     */
    public transformFretProperty(branch: SPPTBranch): FretProperty {
        // console.log('transformFretProperty called: ' + branch.name);
        let __name: string;
        let __type: MetaElementReference<FreMetaClassifier>;
        const children = this.mainAnalyser.getChildren(branch);
        __name = this.mainAnalyser.transformSharedPackedParseTreeNode(children[0]); // RHSPrimEntry
        __type = this.mainAnalyser.freNodeRef<FreMetaClassifier>(children[2], "FreClassifier"); // RHSRefEntry
        return FretProperty.create({
            name: __name,
            typeReference: __type,
            aglParseLocation: this.mainAnalyser.location(branch),
        });
    }

    /**
     * Method to transform branches that match the following rule:
     * FretTypeRule = FretInferenceRule
     *    | FretConformanceRule
     *    | FretEqualsRule
     *    | FretLimitedRule  ;
     * @param branch
     * @private
     */
    public transformFretTypeRule(branch: SPPTBranch): FretTypeRule {
        // console.log('transformFretTypeRule called: ' + branch.name);
        return this.mainAnalyser.transformSharedPackedParseTreeNode(branch.nonSkipChildren.toArray()[0]);
    }

    /**
     * Method to transform branches that match the following rule:
     * FretExp = FretPropertyCallExp
     *    | FretSelfExp
     *    | FretAnytypeExp
     *    | FretVarCallExp
     *    | FretCreateExp
     *    | FretLimitedInstanceExp
     *    | FretWhereExp
     *    | FretFunctionCallExp
     *    | __fre_binary_FretExp ;
     * @param branch
     * @private
     */
    public transformFretExp(branch: SPPTBranch): FretExp {
        // console.log('transformFretExp called: ' + branch.name);
        return this.mainAnalyser.transformSharedPackedParseTreeNode(branch.nonSkipChildren.toArray()[0]);
    }

    /**
     * Generic method to transform binary expressions, which are parsed
     * according to these rules:
     * __fre_binary_FretExp = [FretExp / __fre_binary_operator]2+ ;
     * leaf __fre_binary_operator = 'conformsto' | 'equalsto' ;
     *
     * In this method we build a crooked tree, which in a later phase needs to be balanced
     * according to the priorities of the operators.
     * @param branch
     * @private
     */
    public transform__fre_binary_FretExp(branch: SPPTBranch): FretExp {
        // console.log('transform__fre_binary_FretExp called: ' + branch.name);
        const children = branch.nonSkipChildren.toArray();
        let index = 0;
        let first = this.mainAnalyser.transformSharedPackedParseTreeNode(children[index++]);
        while (index < children.length) {
            const operator = this.mainAnalyser.transformSharedPackedParseTreeNode(children[index++]);
            const second = this.mainAnalyser.transformSharedPackedParseTreeNode(children[index++]);
            let combined: FretExp | undefined = undefined;

            switch (operator) {
                case "equalsto": {
                    combined = FretEqualsExp.create({
                        left: first,
                        right: second,
                        aglParseLocation: this.mainAnalyser.location(branch),
                    });
                    break;
                }
                case "conformsto": {
                    combined = FretConformsExp.create({
                        left: first,
                        right: second,
                        aglParseLocation: this.mainAnalyser.location(branch),
                    });
                    break;
                }
                default: {
                    combined = undefined;
                }
            }
            first = combined;
        }
        return first;
    }
}
